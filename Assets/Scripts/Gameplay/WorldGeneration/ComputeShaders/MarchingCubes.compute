#pragma kernel March
#include "MarchTables.compute"

static const int numThreads = 8;
static const int edgeThickness = 5;

struct Triangle
{
    float3 vertexC;
    float3 vertexB;
    float3 vertexA;
};

AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float> points;

int numPointsWithThickness;

int numPointsPerAxis;
float isoLevel;

int indexFromCoord(int x, int y, int z)
{
    return z * numPointsWithThickness * numPointsWithThickness + y * numPointsWithThickness + x;
}

int countNeighbours(int x, int y, int z)
{
    int neighbours = 0;
    for (int i = -1; i < 2 + 1; i++)
    {
        for (int j = -1; j < 2 + 1; j++)
        {
            for (int k = -1; k < 2 + 1; k++)
            {
                float iso = points[indexFromCoord(x + i, z + k, y + j)];
                if (iso > isoLevel)
                {
                    neighbours = neighbours + 1;
                }
            }
        }
    }
    
    return neighbours;
}

int sharedNeighbourCounts(int x, int y, int z)
{
    int neighbours = countNeighbours(x, y, z);
    int sharedCount = 0;
    for (int i = -1; i < 2 + 1; i++)
    {
        for (int j = -1; j < 2 + 1; j++)
        {
            for (int k = -1; k < 2 + 1; k++)
            {
                int neighboursCounts = countNeighbours(x + i, y + j, z + k);
                sharedCount = sharedCount + ((neighboursCounts == neighbours) ? 1 : 0);
            }
        }
    }
    
    return sharedCount;
}

float percentageNeighbours(int x, int y, int z)
{
    float iso = points[indexFromCoord(x, z, y)];
    if (iso < isoLevel)
    {
        return 0;
    }
    
    float smoothSize = (edgeThickness * 2 + 1);
    return 0.5 * isoLevel * (sharedNeighbourCounts(x, y, z) / 26.0f + (countNeighbours(x, y, z) / 27.0f));
}

float4 GetVertIntensity(int x, int y, int z)
{
    float intensity = points[indexFromCoord(x, z, y)];
    return float4(float3(x, y, z) * intensity, intensity);
}

float4 vertexAndIntensity(int x, int y, int z)
{
    return float4(x, y, z, percentageNeighbours(x, y, z));
}

float3 interpolateVerts(float4 v1, float4 v2)
{
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

[numthreads(numThreads, numThreads, numThreads)]
void March(int3 id : SV_DispatchThreadID)
{
    int x = id.x + edgeThickness;
    int y = id.y + edgeThickness;
    int z = id.z + edgeThickness;
    
    if (id.x >= numPointsPerAxis - 1 || id.y >= numPointsPerAxis - 1 || id.z >= numPointsPerAxis - 1)
    {
        return;
    }

    float4 cubeCorners[8] =
    {
        vertexAndIntensity(x, y, z),
        vertexAndIntensity(x + 1, y, z),
        vertexAndIntensity(x + 1, y, z + 1),
        vertexAndIntensity(x, y, z + 1),
        vertexAndIntensity(x, y + 1, z),
        vertexAndIntensity(x + 1, y + 1, z),
        vertexAndIntensity(x + 1, y + 1, z + 1),
        vertexAndIntensity(x, y + 1, z + 1)
    };

    int cubeIndex = 0;
    if (cubeCorners[0].w < isoLevel)
        cubeIndex |= 1;
    if (cubeCorners[1].w < isoLevel)
        cubeIndex |= 2;
    if (cubeCorners[2].w < isoLevel)
        cubeIndex |= 4;
    if (cubeCorners[3].w < isoLevel)
        cubeIndex |= 8;
    if (cubeCorners[4].w < isoLevel)
        cubeIndex |= 16;
    if (cubeCorners[5].w < isoLevel)
        cubeIndex |= 32;
    if (cubeCorners[6].w < isoLevel)
        cubeIndex |= 64;
    if (cubeCorners[7].w < isoLevel)
        cubeIndex |= 128;

    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3)
    {
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i + 2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i + 2]];

        Triangle tri;
        tri.vertexA = interpolateVerts(cubeCorners[a0], cubeCorners[b0]);
        tri.vertexB = interpolateVerts(cubeCorners[a1], cubeCorners[b1]);
        tri.vertexC = interpolateVerts(cubeCorners[a2], cubeCorners[b2]);
        triangles.Append(tri);
    }
}
